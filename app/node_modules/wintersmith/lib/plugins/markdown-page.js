// Generated by CoffeeScript 1.4.0
var Highlight, MarkdownPage, Page, async, extractMetadata, fs, is_relative, logger, marked, parseMarkdownSync, parseMetadata, path, url, yaml,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Highlight = require('highlight').Highlight;

marked = require('marked');

async = require('async');

path = require('path');

url = require('url');

fs = require('fs');

yaml = require('js-yaml');

logger = require('./../common').logger;

Page = require('./page');

is_relative = function(uri) {
  /* returns true if *uri* is relative; otherwise false
  */
  return url.parse(uri).protocol === void 0;
};

parseMetadata = function(source, callback) {
  try {
    return callback(null, yaml.load(source) || {});
  } catch (error) {
    return callback(error);
  }
};

extractMetadata = function(content, callback) {
  var markdown, metadata, result, split_idx;
  if (content.slice(0, 3) === '---') {
    result = content.match(/-{3,}\s([\s\S]*?)-{3,}\s([\s\S]*)/);
    if ((result != null ? result.length : void 0) === 3) {
      metadata = result[1];
      markdown = result[2];
    } else {
      metadata = '';
      markdown = content;
    }
  } else {
    logger.warn('Deprecation warning: page metadata should be encapsulated by at least three dashes (---)');
    split_idx = content.indexOf('\n\n');
    metadata = content.slice(0, split_idx);
    markdown = content.slice(split_idx + 2);
  }
  return async.parallel({
    metadata: function(callback) {
      return parseMetadata(metadata, callback);
    },
    markdown: function(callback) {
      return callback(null, markdown);
    }
  }, callback);
};

parseMarkdownSync = function(content, baseUrl) {
  /* takes markdown *content* and returns html using *baseUrl* for any relative urls
      returns html
  */

  var token, tokens, _i, _len;
  marked.inlineLexer.formatUrl = function(uri) {
    if (is_relative(uri)) {
      return url.resolve(baseUrl, uri);
    } else {
      return uri;
    }
  };
  tokens = marked.lexer(content);
  for (_i = 0, _len = tokens.length; _i < _len; _i++) {
    token = tokens[_i];
    switch (token.type) {
      case 'code':
        token.text = Highlight(token.text, '  ');
        token.escaped = true;
    }
  }
  return marked.parser(tokens);
};

MarkdownPage = (function(_super) {

  __extends(MarkdownPage, _super);

  function MarkdownPage() {
    return MarkdownPage.__super__.constructor.apply(this, arguments);
  }

  MarkdownPage.prototype.getLocation = function(base) {
    var uri;
    uri = this.getUrl(base);
    return uri.slice(0, +uri.lastIndexOf('/') + 1 || 9e9);
  };

  MarkdownPage.prototype.getHtml = function(base) {
    /* parse @markdown and return html. also resolves any relative urls to absolute ones
    */

    var _ref;
    if ((_ref = this._html) == null) {
      this._html = parseMarkdownSync(this._content, this.getLocation(base));
    }
    return this._html;
  };

  return MarkdownPage;

})(Page);

MarkdownPage.fromFile = function(filename, base, callback) {
  var _this = this;
  return async.waterfall([
    function(callback) {
      return fs.readFile(path.join(base, filename), callback);
    }, function(buffer, callback) {
      return extractMetadata(buffer.toString(), callback);
    }, function(result, callback) {
      var markdown, metadata, page;
      markdown = result.markdown, metadata = result.metadata;
      page = new _this(filename, markdown, metadata);
      return callback(null, page);
    }
  ], callback);
};

module.exports = MarkdownPage;
